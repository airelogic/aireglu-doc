import{_ as e,c as t,o as n,a4 as a}from"./chunks/framework.ttppV29E.js";const k=JSON.parse('{"title":"JWT Task","description":"","frontmatter":{},"headers":[],"relativePath":"docs/endpoints/jwt.md","filePath":"docs/endpoints/jwt.md","lastUpdated":1739789377000}'),s={name:"docs/endpoints/jwt.md"},i=a('<h1 id="jwt-task" tabindex="-1">JWT Task <a class="header-anchor" href="#jwt-task" aria-label="Permalink to &quot;JWT Task&quot;">​</a></h1><p>The JWT task allows you to generate a JWT with customisable headers &amp; payload, with a choice of encryption and/or signing algorithms.</p><h2 id="signed-tokens-rs256-rs512" tabindex="-1">Signed Tokens (rs256 &amp; rs512) <a class="header-anchor" href="#signed-tokens-rs256-rs512" aria-label="Permalink to &quot;Signed Tokens (rs256 &amp; rs512)&quot;">​</a></h2><p>The <code>rs256</code> &amp; <code>rs512</code> algorithms will give you an unencrypted token signed using the assymettric RSA algorithm. You should specify the private key in the Signing Secret field, then anyone with the corresponding public key will be able to verify your token.</p><h2 id="signed-encrypted-tokens-aes128-hs256" tabindex="-1">Signed &amp; Encrypted Tokens (aes128-hs256) <a class="header-anchor" href="#signed-encrypted-tokens-aes128-hs256" aria-label="Permalink to &quot;Signed &amp; Encrypted Tokens (aes128-hs256)&quot;">​</a></h2><p>The <code>aes128-hs256</code> algorithm will give you a token which is first signed using the symmettric HS256 algorithm, then encrypted with AES128. You should specify the 256 bit (32 character) HS256 signing key in the Signing Secret field and the 128 bit (16 character) AES128 encryption key in the Encryption Secret field. Because these are both symmettric algorithms, the same encryption and signing keys must be used to decrypt and verify tokens generated using this algorithm.</p><h2 id="unsigned-tokens" tabindex="-1">Unsigned Tokens <a class="header-anchor" href="#unsigned-tokens" aria-label="Permalink to &quot;Unsigned Tokens&quot;">​</a></h2><p>The <code>none</code> algorithm will give you a token which is neither signed nor encrypted.</p>',8),o=[i];function r(d,h,c,l,p,g){return n(),t("div",null,o)}const u=e(s,[["render",r]]);export{k as __pageData,u as default};
